#pragma shader_stage(compute)

#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

#include "include/Random.glsl"
#include "include/TonemapFunctions.glsl"
#include "include/Math.glsl"

struct SceneData {
    // Camera
	mat4 inverseProjection;
	mat4 inverseView;
    vec3 position;
    uint maxBounceCount;
    uint samples;
    uint sphereCount;
    uint drawCommandCount;
    uint renderedFramesCount;

    uint boxID;
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 invDirection;
};

#define MaterialID uint
#define MaterialType uint
#define MATERIAL_METAL 0
#define MATERIAL_DIELECTRIC 1

struct Material {
    MaterialType type;
    vec3 albedo;
    vec3 emission;
    float emissionStrength;

    float metallic;
    float roughness;

    vec3 absorption; 
 	float absorptionStrength;
    float ior;
};


struct HitInfo {
    vec3 p;
    vec3 normal;
    float t;
    bool hit;
    bool front;
    vec2 uv;
    MaterialID material;
};

struct Sphere {
	vec3 position;
	float radius;
	MaterialID material;
};

struct Node {
	vec3 min;
	vec3 max;

    uint leftNodeOrTriangleIndex;
	uint triangleCount;
};

layout(buffer_reference, scalar) buffer SceneDataPointer { SceneData sceneData; };
layout(buffer_reference, scalar) buffer MaterialBufferPointer { Material materials[]; };
layout(buffer_reference, scalar) buffer SphereBufferPointer { Sphere spheres[]; };

layout(buffer_reference, scalar) buffer VertexBufferPointer { vec3 vertices[]; };
layout(buffer_reference, scalar) buffer IndexBufferPointer { uint indices[]; };
layout(buffer_reference, scalar) buffer BVHBufferPointer { Node bvh[]; };

struct DrawCommand {
    VertexBufferPointer vertexBP;
    IndexBufferPointer indexBP;
    BVHBufferPointer bvhBP;
    uint indexCount;
};
layout(buffer_reference, scalar) buffer DrawCommandPointer { DrawCommand drawCommands[]; };

layout(push_constant) uniform Data {
    SceneDataPointer sdp;
    MaterialBufferPointer mbp;
    SphereBufferPointer sphereBP;
    DrawCommandPointer drawCommandBP;
};

vec2 rayBoxIntersect(Ray ray, vec3 bmin, vec3 bmax) {
    vec3 tbot = (bmin - ray.origin) * ray.invDirection;
    vec3 ttop = (bmax - ray.origin) * ray.invDirection;
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    vec2 t = max(tmin.xx, tmin.yz);
    float t0 = max(t.x, t.y);
    t = min(tmax.xx, tmax.yz);
    float t1 = min(t.x, t.y);

    return vec2(t0, t1);
}

vec2 raySphereIntersect(Ray ray, vec3 position, float radius) {    
 	vec3 oc = ray.origin - position;
    float b = dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float t = b * b - c;
    if (t < 0.0) return vec2(-1.0);

    float s = sqrt(t);
    return vec2(-b - s, -b + s);
}

vec3 rayTriangleIntersect(Ray ray, vec3 a, vec3 b, vec3 c) {
	vec3 edgeAB = b - a;
	vec3 edgeAC = c - a;
	vec3 oa = ray.origin - a;
    vec3 crossRDE2 = cross(ray.direction, edgeAC);
    float dotE1CrossRDE2 = 1.0 / dot(edgeAB, crossRDE2);
	vec3 crossROAE1 = cross(oa, edgeAB);
	vec2 uv = vec2(dot(oa, crossRDE2) * dotE1CrossRDE2, dot(ray.direction, crossROAE1 * dotE1CrossRDE2));

	float t = dot(edgeAC, crossROAE1) * dotE1CrossRDE2;
    return (t > 0.0 && uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.x + uv.y <= 1.0) ? 
    vec3(t, uv) : vec3(-1.0, uv);
}

HitInfo Intersect(Ray ray) {
    HitInfo rec;
    rec.t = kInfinity;
    rec.hit = false;

    for (int i = 0; i < sdp.sceneData.sphereCount; i++) {
        float tempRec = raySphereIntersect(ray, sphereBP.spheres[i].position, sphereBP.spheres[i].radius).x; 
        if (tempRec > 0.0 && tempRec < rec.t) {
            rec.t = tempRec;
            rec.p = ray.origin + rec.t * ray.direction;
            rec.normal = (rec.p - sphereBP.spheres[i].position) / sphereBP.spheres[i].radius;
            rec.hit = true;
            rec.material = sphereBP.spheres[i].material;
        }
    }

    uint nodeStack[32];
    for (int i = 0; i < sdp.sceneData.drawCommandCount; i++) {
        DrawCommand drawCommand = drawCommandBP.drawCommands[i];
        int stackIndex = 0;
        nodeStack[stackIndex++] = 0;

        while(stackIndex > 0) {
            uint nodeIdx = nodeStack[--stackIndex];
            Node node = drawCommand.bvhBP.bvh[nodeIdx];
            
            vec2 bvhT = rayBoxIntersect(ray, node.min, node.max);
            if (bvhT.x > bvhT.y || bvhT.y < 0.0 || bvhT.x > rec.t) continue; 
            
            if (node.triangleCount > 0) {
                for (uint i = 0; i < node.triangleCount; i += 3) {
                    vec3 a = drawCommand.vertexBP.vertices[drawCommand.indexBP.indices[i + node.leftNodeOrTriangleIndex + 0]];
                    vec3 b = drawCommand.vertexBP.vertices[drawCommand.indexBP.indices[i + node.leftNodeOrTriangleIndex + 1]];
                    vec3 c = drawCommand.vertexBP.vertices[drawCommand.indexBP.indices[i + node.leftNodeOrTriangleIndex + 2]];
                    
                    vec3 tempRec = rayTriangleIntersect(ray, a, b, c); 
                    if (tempRec.x != -1.0 && tempRec.x < rec.t) {
                        rec.t = tempRec.x;
                        rec.normal = normalize(cross(b - a, c - a)); // @NOTE: This is slow
                        rec.hit = true;
                        rec.material = 0;
                    }
                }
            }
            else {
                uint leftChild = node.leftNodeOrTriangleIndex;
                uint rightChild = leftChild + 1;
                
                Node leftNode = drawCommand.bvhBP.bvh[leftChild];
                Node rightNode = drawCommand.bvhBP.bvh[rightChild];
                
                vec2 leftT  = rayBoxIntersect(ray, leftNode.min,  leftNode.max);
                vec2 rightT = rayBoxIntersect(ray, rightNode.min, rightNode.max);
                
                float leftDist =  (leftT.x  > 0.0) ? leftT.x  : leftT.y;
                float rightDist = (rightT.x > 0.0) ? rightT.x : rightT.y;
                
                if (leftDist < rightDist) {
                    nodeStack[stackIndex++] = rightChild;
                    nodeStack[stackIndex++] = leftChild;
                } else {
                    nodeStack[stackIndex++] = leftChild;
                    nodeStack[stackIndex++] = rightChild;
                }
            }
        }
    }

    
    if (rec.hit) {
        rec.p = ray.origin + rec.t * ray.direction;
        rec.front = dot(ray.direction, rec.normal) < 0.0;
        if (!rec.front) rec.normal *= -1.0;
    }

    return rec;
}

float CalculateReflectance(vec3 inDir, vec3 normal, float iorA, float iorB) {
    float refractRatio = iorA / iorB;
    float cosAngleIn = -dot(inDir, normal);
    float sinSqrAngleOfRefraction = refractRatio * refractRatio * (1 - cosAngleIn * cosAngleIn);
    if (sinSqrAngleOfRefraction >= 1) return 1; // Ray is fully reflected, no refraction occurs

    float cosAngleOfRefraction = sqrt(1 - sinSqrAngleOfRefraction);
    float denominatorPerpendicular = iorA * cosAngleIn + iorB * cosAngleOfRefraction;
    float denominatorParallel = iorB * cosAngleIn + iorA * cosAngleOfRefraction;

    if (min(denominatorPerpendicular, denominatorParallel) < 1E-8) return 1;

    // Perpendicular polarization
    float rPerpendicular = (iorA * cosAngleIn - iorB * cosAngleOfRefraction) / denominatorPerpendicular;
    rPerpendicular *= rPerpendicular;
    // Parallel polarization
    float rParallel = (iorB * cosAngleIn - iorA * cosAngleOfRefraction) / denominatorParallel;
    rParallel *= rParallel;

    // Return the average of the perpendicular and parallel polarizations
    return (rPerpendicular + rParallel) / 2;
}

vec3 ray_color(Ray ray) {
    float a = 0.5 * (ray.direction.y + 1.0);
    return mix(vec3(0.5, 0.7, 1.0), vec3(1.0), a);
}

vec3 TraceRay(Ray ray, inout uint rngState) {
    vec3 totalLight = vec3(0.0);
    vec3 transmittance = vec3(1.0);

    for(int i = 0; i <= sdp.sceneData.maxBounceCount; i++) { 
        HitInfo hitInfo = Intersect(ray);
        
        if (!hitInfo.hit)
            return totalLight + ray_color(ray) * transmittance;

        Material material = mbp.materials[hitInfo.material];
        
        totalLight += material.emission * material.emissionStrength * transmittance;

        
        if (material.type == MATERIAL_METAL) {
            ray.origin = hitInfo.p + hitInfo.normal * bias;
            ray.direction = normalize(reflect(ray.direction, hitInfo.normal) + material.roughness * RandomDirection(rngState));
            ray.invDirection = 1.0 / ray.direction;
            
            transmittance *= material.albedo;
        }
        else {
            // Determine eta in/out explicitly
            float etaI = hitInfo.front ? 1.0 : material.ior;
            float etaT = hitInfo.front ? material.ior : 1.0;

            float reflectProb = CalculateReflectance(ray.direction, hitInfo.normal, etaI, etaT);

            vec3 R = reflect(ray.direction, hitInfo.normal);
            vec3 T = refract(ray.direction, hitInfo.normal, etaI / etaT);

            bool followReflection = (T.x == 0.0 && T.y == 0.0 && T.z == 0.0) || (rand(rngState) <= reflectProb);

            ray.direction = normalize((followReflection ? R : T) + material.roughness * RandomDirection(rngState));
            ray.invDirection = 1.0 / ray.direction;
            
            if (!followReflection && !hitInfo.front) transmittance *= exp(-material.absorption * material.absorptionStrength * hitInfo.t);
            ray.origin = hitInfo.p + bias * hitInfo.normal * sign(dot(ray.direction, hitInfo.normal));
        }
    }

    return totalLight;
}

layout(local_size_x = 4, local_size_y = 4) in;
layout(binding = 0, rgba32f) restrict uniform image2D o_Image;

void main() {
    vec2 imgSize = vec2(imageSize(o_Image));

    ivec2 invocID = ivec2(gl_GlobalInvocationID);
    vec2 coord = vec2(float(invocID.x) / imgSize.x, float(invocID.y) / imgSize.y);
    coord += (1.0 / imgSize) * 0.5;

    coord.y = 1.0 - coord.y;
    coord = coord * 2.0 - 1.0; // -1 -> 1
        
    SceneData sceneData = sdp.sceneData;

    vec4 target = sceneData.inverseProjection * vec4(coord.x, coord.y, 1, 1);
    vec3 rayDirection = normalize(vec3(sceneData.inverseView * vec4(normalize(vec3(target) / target.w), 0.0)));

    uint pixel_index = invocID.x + invocID.y * uint(imgSize.x) + sceneData.renderedFramesCount * 719393;
    uint seed = pcg_hash(pixel_index);

    vec3 result = vec3(0.0);
    
    for (int i = 0; i < sdp.sceneData.samples; i++)
        result += TraceRay(Ray(sceneData.position, rayDirection, 1.0 / rayDirection), seed);
       
    result /= sdp.sceneData.samples;

    vec3 oldRender = imageLoad(o_Image, ivec2(gl_GlobalInvocationID)).rgb;

    float weight = 1.0 / (sceneData.renderedFramesCount + 1);
    vec3 accumulatedAverage = mix(oldRender, result, weight);
    if (sceneData.renderedFramesCount == 0) accumulatedAverage = result;

    //result = pow(result, vec3(1.0 / 2.0));
    //result = PBRNeutral(result);

    imageStore(o_Image, ivec2(gl_GlobalInvocationID), vec4(accumulatedAverage, 1.0));
}