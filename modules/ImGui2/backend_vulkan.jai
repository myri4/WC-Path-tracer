//
// This file was autogenerated.
//



// Initialization data, for ImGui_ImplVulkan_Init()
// [Please zero-clear before use!]
// - About descriptor pool:
//   - A VkDescriptorPool should be created with VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
//     and must contain a pool size large enough to hold a small number of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER descriptors.
//   - As an convenience, by setting DescriptorPoolSize > 0 the backend will create one for you.
// - About dynamic rendering:
//   - When using dynamic rendering, set UseDynamicRendering=true and fill PipelineRenderingCreateInfo structure.
ImplVulkan_InitInfo :: struct {
    ApiVersion:                  u32; // Fill with API version of Instance, e.g. VK_API_VERSION_1_3 or your value of VkApplicationInfo::apiVersion. May be lower than header version (VK_HEADER_VERSION_COMPLETE)
    Instance:                    VkInstance;
    PhysicalDevice:              VkPhysicalDevice;
    Device:                      VkDevice;
    QueueFamily:                 u32;
    Queue:                       VkQueue;
    DescriptorPool:              VkDescriptorPool; // See requirements in note above; ignored if using DescriptorPoolSize > 0
    DescriptorPoolSize:          u32; // Optional: set to create internal descriptor pool automatically instead of using DescriptorPool.
    MinImageCount:               u32; // >= 2
    ImageCount:                  u32; // >= MinImageCount
    PipelineCache:               VkPipelineCache; // Optional

    RenderPass:                  VkRenderPass; // Ignored if using dynamic rendering
    Subpass:                     u32;
    MSAASamples:                 VkSampleCountFlagBits; // 0 defaults to VK_SAMPLE_COUNT_1_BIT

    // (Optional) Dynamic Rendering
    // Need to explicitly enable VK_KHR_dynamic_rendering extension to use this, even for Vulkan 1.3 + setup PipelineRenderingCreateInfo.
    UseDynamicRendering:         bool;

    PipelineRenderingCreateInfo: VkPipelineRenderingCreateInfoKHR; // Optional, valid if .sType == VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR

    // (Optional) Allocation, Debugging
    Allocator:                   *VkAllocationCallbacks;
    CheckVkResultFn:             #type (err: VkResult) -> void #c_call;
    MinAllocationSize:           VkDeviceSize; // Minimum allocation size. Set to 1024*1024 to satisfy zealous best practices validation layer and waste a little memory.
}

// Follow "Getting Started" link and check examples/ folder to learn about using backends!
ImplVulkan_Init :: (info: *ImplVulkan_InitInfo) -> bool #foreign backend_vulkan "?ImGui_ImplVulkan_Init@@YA_NPEAUImGui_ImplVulkan_InitInfo@@@Z";
ImplVulkan_Shutdown :: () -> void #foreign backend_vulkan "?ImGui_ImplVulkan_Shutdown@@YAXXZ";
ImplVulkan_NewFrame :: () -> void #foreign backend_vulkan "?ImGui_ImplVulkan_NewFrame@@YAXXZ";
ImplVulkan_RenderDrawData :: (draw_data: *DrawData, command_buffer: VkCommandBuffer, pipeline: VkPipeline = null) -> void #foreign backend_vulkan "?ImGui_ImplVulkan_RenderDrawData@@YAXPEAUImDrawData@@PEAUVkCommandBuffer_T@@PEAUVkPipeline_T@@@Z";
ImplVulkan_SetMinImageCount :: (min_image_count: u32) -> void #foreign backend_vulkan "?ImGui_ImplVulkan_SetMinImageCount@@YAXI@Z";

// (Advanced) Use e.g. if you need to recreate pipeline without reinitializing the backend (see #8110, #8111)
// The main window pipeline will be created by ImGui_ImplVulkan_Init() if possible (== RenderPass xor (UseDynamicRendering && PipelineRenderingCreateInfo->sType == VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR))
// Else, the pipeline can be created, or re-created, using ImGui_ImplVulkan_CreateMainPipeline() before rendering.
ImplVulkan_MainPipelineCreateInfo :: struct {
    RenderPass_:                 VkRenderPass = null;
    Subpass:                     u32 = 0;
    MSAASamples:                 VkSampleCountFlagBits;

    PipelineRenderingCreateInfo: VkPipelineRenderingCreateInfoKHR; // Optional, valid if .sType == VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR
}

ImplVulkan_CreateMainPipeline :: (info: *ImplVulkan_MainPipelineCreateInfo) -> void #foreign backend_vulkan "?ImGui_ImplVulkan_CreateMainPipeline@@YAXAEBUImGui_ImplVulkan_MainPipelineCreateInfo@@@Z";
ImplVulkan_CreateMainPipeline :: (info: ImplVulkan_MainPipelineCreateInfo) #no_context {
    ImplVulkan_CreateMainPipeline(*info);
}

// (Advanced) Use e.g. if you need to precisely control the timing of texture updates (e.g. for staged rendering), by setting ImDrawData::Textures = NULL to handle this manually.
ImplVulkan_UpdateTexture :: (tex: *TextureData) -> void #foreign backend_vulkan "?ImGui_ImplVulkan_UpdateTexture@@YAXPEAUImTextureData@@@Z";

// Register a texture (VkDescriptorSet == ImTextureID)
// FIXME: This is experimental in the sense that we are unsure how to best design/tackle this problem
// Please post to https://github.com/ocornut/imgui/pull/914 if you have suggestions.
ImplVulkan_AddTexture :: (sampler: VkSampler, image_view: VkImageView, image_layout: VkImageLayout) -> VkDescriptorSet #foreign backend_vulkan "?ImGui_ImplVulkan_AddTexture@@YAPEAUVkDescriptorSet_T@@PEAUVkSampler_T@@PEAUVkImageView_T@@W4VkImageLayout@@@Z";
ImplVulkan_RemoveTexture :: (descriptor_set: VkDescriptorSet) -> void #foreign backend_vulkan "?ImGui_ImplVulkan_RemoveTexture@@YAXPEAUVkDescriptorSet_T@@@Z";

// Optional: load Vulkan functions with a custom function loader
// This is only useful with IMGUI_IMPL_VULKAN_NO_PROTOTYPES / VK_NO_PROTOTYPES
ImplVulkan_LoadFunctions :: (api_version: u32, loader_func: #type (function_name: *u8, user_data: *void) -> PFN_vkVoidFunction #c_call, user_data: *void = null) -> bool #foreign backend_vulkan "?ImGui_ImplVulkan_LoadFunctions@@YA_NIP6AP6AXXZPEBDPEAX@Z1@Z";

// [BETA] Selected render state data shared with callbacks.
// This is temporarily stored in GetPlatformIO().Renderer_RenderState during the ImGui_ImplVulkan_RenderDrawData() call.
// (Please open an issue if you feel you need access to more data)
ImplVulkan_RenderState :: struct {
    CommandBuffer_:  VkCommandBuffer;
    Pipeline_:       VkPipeline;
    PipelineLayout_: VkPipelineLayout;
}

#scope_file

#import "Vulkan2";
backend_vulkan :: #library,no_dll "windows/backend_vulkan";
